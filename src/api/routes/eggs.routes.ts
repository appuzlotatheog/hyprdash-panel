import { Router } from 'express';
import { z } from 'zod';
import { prisma } from '../../lib/prisma.js';
import { authenticate, requireAdmin, AuthRequest } from '../../middleware/auth.js';
import { AppError } from '../../middleware/errorHandler.js';

const router = Router();

// All routes require authentication
router.use(authenticate);

// Validation schemas
const createEggSchema = z.object({
    name: z.string().min(1).max(100),
    author: z.string().optional(),
    description: z.string().optional(),
    features: z.array(z.string()).optional(),
    dockerImages: z.record(z.string()).optional(),
    startup: z.string().min(1),
    stopCommand: z.string().default('stop'),
    configFiles: z.string().optional(),
    configStartup: z.string().optional(),
    scriptInstall: z.string().optional(),
    scriptContainer: z.string().optional(),
    fileDenylist: z.array(z.string()).optional(),
    variables: z.array(z.object({
        name: z.string().min(1),
        description: z.string().optional(),
        envVariable: z.string().min(1),
        defaultValue: z.string().optional(),
        userViewable: z.boolean().default(true),
        userEditable: z.boolean().default(true),
        rules: z.string().optional(),
        fieldType: z.string().default('text'),
    })).optional(),
});

const updateEggSchema = z.object({
    name: z.string().min(1).max(100).optional(),
    author: z.string().optional(),
    description: z.string().optional(),
    features: z.array(z.string()).optional(),
    dockerImages: z.record(z.string()).optional(),
    startup: z.string().optional(),
    stopCommand: z.string().optional(),
    configFiles: z.string().optional(),
    configStartup: z.string().optional(),
    scriptInstall: z.string().optional(),
    scriptContainer: z.string().optional(),
    fileDenylist: z.array(z.string()).optional(),
});

// Pterodactyl egg import schema
const pterodactylEggSchema = z.object({
    meta: z.object({
        version: z.string(),
    }).optional(),
    name: z.string(),
    author: z.string().optional(),
    description: z.string().optional(),
    features: z.array(z.string()).optional(),
    docker_images: z.record(z.string()).optional(),
    startup: z.string(),
    config: z.object({
        files: z.string().optional(),
        startup: z.string().optional(),
        stop: z.string().optional(),
    }).optional(),
    scripts: z.object({
        installation: z.object({
            script: z.string().optional(),
            container: z.string().optional(),
        }).optional(),
    }).optional(),
    file_denylist: z.array(z.string()).optional(),
    variables: z.array(z.object({
        name: z.string(),
        description: z.string().optional(),
        env_variable: z.string(),
        default_value: z.string().optional(),
        user_viewable: z.boolean().optional(),
        user_editable: z.boolean().optional(),
        rules: z.string().optional(),
        field_type: z.string().optional(),
    })).optional(),
});

// GET /api/eggs - List all eggs
router.get('/', async (_req: AuthRequest, res, next) => {
    try {
        const eggs = await prisma.egg.findMany({
            include: {
                variables: true,
                _count: { select: { servers: true } },
            },
            orderBy: { name: 'asc' },
        });

        res.json({ eggs });
    } catch (error) {
        next(error);
    }
});

// GET /api/eggs/:id - Get egg details
router.get('/:id', async (req: AuthRequest, res, next) => {
    try {
        const { id } = req.params;

        const egg = await prisma.egg.findUnique({
            where: { id },
            include: {
                variables: true,
                servers: {
                    select: { id: true, name: true },
                    take: 10,
                },
            },
        });

        if (!egg) {
            throw new AppError(404, 'Egg not found');
        }

        res.json({ egg });
    } catch (error) {
        next(error);
    }
});

// GET /api/eggs/:id/export - Export egg as Pterodactyl JSON
router.get('/:id/export', requireAdmin, async (req: AuthRequest, res, next) => {
    try {
        const { id } = req.params;

        const egg = await prisma.egg.findUnique({
            where: { id },
            include: { variables: true },
        });

        if (!egg) {
            throw new AppError(404, 'Egg not found');
        }

        // Convert to Pterodactyl format
        const pterodactylEgg = {
            _comment: 'DO NOT EDIT: FILE GENERATED BY GAME PANEL',
            meta: {
                version: 'PTDL_v2',
                update_url: null,
            },
            exported_at: new Date().toISOString(),
            name: egg.name,
            author: egg.author || 'unknown@panel.local',
            description: egg.description || '',
            features: egg.features ? JSON.parse(egg.features) : [],
            docker_images: egg.dockerImages ? JSON.parse(egg.dockerImages) : {},
            file_denylist: egg.fileDenylist ? JSON.parse(egg.fileDenylist) : [],
            startup: egg.startup,
            config: {
                files: egg.configFiles || '{}',
                startup: egg.configStartup || '{}',
                logs: '{}',
                stop: egg.stopCommand || 'stop',
            },
            scripts: {
                installation: {
                    script: egg.scriptInstall || '#!/bin/bash\necho "No installation script"',
                    container: egg.scriptContainer || 'alpine:latest',
                    entrypoint: 'bash',
                },
            },
            variables: egg.variables.map(v => ({
                name: v.name,
                description: v.description || '',
                env_variable: v.envVariable,
                default_value: v.defaultValue || '',
                user_viewable: v.userViewable,
                user_editable: v.userEditable,
                rules: v.rules || 'nullable|string',
                field_type: v.fieldType || 'text',
            })),
        };

        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', `attachment; filename="egg-${egg.name.toLowerCase().replace(/\s+/g, '-')}.json"`);
        res.json(pterodactylEgg);
    } catch (error) {
        next(error);
    }
});

// POST /api/eggs/import - Import Pterodactyl egg JSON
router.post('/import', requireAdmin, async (req: AuthRequest, res, next) => {
    try {
        const data = pterodactylEggSchema.parse(req.body);

        // Check if egg with same name exists
        const existing = await prisma.egg.findFirst({
            where: { name: data.name },
        });

        if (existing) {
            throw new AppError(400, `Egg "${data.name}" already exists. Delete it first or use a different name.`);
        }

        // Create egg from Pterodactyl format
        const egg = await prisma.egg.create({
            data: {
                name: data.name,
                author: data.author,
                description: data.description,
                features: data.features ? JSON.stringify(data.features) : null,
                dockerImages: data.docker_images ? JSON.stringify(data.docker_images) : null,
                startup: data.startup,
                configFiles: data.config?.files,
                configStartup: data.config?.startup,
                stopCommand: data.config?.stop || 'stop',
                scriptInstall: data.scripts?.installation?.script,
                scriptContainer: data.scripts?.installation?.container,
                fileDenylist: data.file_denylist ? JSON.stringify(data.file_denylist) : null,
                variables: data.variables ? {
                    create: data.variables.map(v => ({
                        name: v.name,
                        description: v.description,
                        envVariable: v.env_variable,
                        defaultValue: v.default_value,
                        userViewable: v.user_viewable ?? true,
                        userEditable: v.user_editable ?? true,
                        rules: v.rules,
                        fieldType: v.field_type || 'text',
                    })),
                } : undefined,
            },
            include: { variables: true },
        });

        res.status(201).json({
            message: `Successfully imported egg "${data.name}"`,
            egg
        });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return next(new AppError(400, `Invalid egg format: ${error.errors[0].message}`));
        }
        next(error);
    }
});

// POST /api/eggs - Create egg (Admin only)
router.post('/', requireAdmin, async (req: AuthRequest, res, next) => {
    try {
        const data = createEggSchema.parse(req.body);

        const egg = await prisma.egg.create({
            data: {
                name: data.name,
                author: data.author,
                description: data.description,
                features: data.features ? JSON.stringify(data.features) : null,
                dockerImages: data.dockerImages ? JSON.stringify(data.dockerImages) : null,
                startup: data.startup,
                stopCommand: data.stopCommand,
                configFiles: data.configFiles,
                configStartup: data.configStartup,
                scriptInstall: data.scriptInstall,
                scriptContainer: data.scriptContainer,
                fileDenylist: data.fileDenylist ? JSON.stringify(data.fileDenylist) : null,
                variables: data.variables ? {
                    create: data.variables,
                } : undefined,
            },
            include: { variables: true },
        });

        res.status(201).json({ egg });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return next(new AppError(400, error.errors[0].message));
        }
        next(error);
    }
});

// PATCH /api/eggs/:id - Update egg (Admin only)
router.patch('/:id', requireAdmin, async (req: AuthRequest, res, next) => {
    try {
        const { id } = req.params;
        const data = updateEggSchema.parse(req.body);

        const egg = await prisma.egg.findUnique({
            where: { id },
        });

        if (!egg) {
            throw new AppError(404, 'Egg not found');
        }

        // Prepare update data
        const updateData: any = {};
        if (data.name !== undefined) updateData.name = data.name;
        if (data.author !== undefined) updateData.author = data.author;
        if (data.description !== undefined) updateData.description = data.description;
        if (data.features !== undefined) updateData.features = JSON.stringify(data.features);
        if (data.dockerImages !== undefined) updateData.dockerImages = JSON.stringify(data.dockerImages);
        if (data.startup !== undefined) updateData.startup = data.startup;
        if (data.stopCommand !== undefined) updateData.stopCommand = data.stopCommand;
        if (data.configFiles !== undefined) updateData.configFiles = data.configFiles;
        if (data.configStartup !== undefined) updateData.configStartup = data.configStartup;
        if (data.scriptInstall !== undefined) updateData.scriptInstall = data.scriptInstall;
        if (data.scriptContainer !== undefined) updateData.scriptContainer = data.scriptContainer;
        if (data.fileDenylist !== undefined) updateData.fileDenylist = JSON.stringify(data.fileDenylist);

        const updated = await prisma.egg.update({
            where: { id },
            data: updateData,
            include: { variables: true },
        });

        res.json({ egg: updated });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return next(new AppError(400, error.errors[0].message));
        }
        next(error);
    }
});

// DELETE /api/eggs/:id - Delete egg (Admin only)
router.delete('/:id', requireAdmin, async (req: AuthRequest, res, next) => {
    try {
        const { id } = req.params;

        const egg = await prisma.egg.findUnique({
            where: { id },
            include: { _count: { select: { servers: true } } },
        });

        if (!egg) {
            throw new AppError(404, 'Egg not found');
        }

        if (egg._count.servers > 0) {
            throw new AppError(400, 'Cannot delete egg with active servers');
        }

        await prisma.egg.delete({
            where: { id },
        });

        res.json({ message: 'Egg deleted' });
    } catch (error) {
        next(error);
    }
});

// --- Egg Variables ---

// POST /api/eggs/:id/variables - Add variable to egg
router.post('/:id/variables', requireAdmin, async (req: AuthRequest, res, next) => {
    try {
        const { id } = req.params;
        const variableSchema = z.object({
            name: z.string().min(1),
            description: z.string().optional(),
            envVariable: z.string().min(1),
            defaultValue: z.string().optional(),
            userViewable: z.boolean().default(true),
            userEditable: z.boolean().default(true),
            rules: z.string().optional(),
            fieldType: z.string().default('text'),
        });
        const data = variableSchema.parse(req.body);

        const egg = await prisma.egg.findUnique({ where: { id } });
        if (!egg) {
            throw new AppError(404, 'Egg not found');
        }

        const variable = await prisma.eggVariable.create({
            data: { eggId: id, ...data },
        });

        res.status(201).json({ variable });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return next(new AppError(400, error.errors[0].message));
        }
        next(error);
    }
});

// PATCH /api/eggs/:id/variables/:variableId - Update egg variable
router.patch('/:id/variables/:variableId', requireAdmin, async (req: AuthRequest, res, next) => {
    try {
        const { id, variableId } = req.params;
        const variableSchema = z.object({
            name: z.string().min(1).optional(),
            description: z.string().optional(),
            envVariable: z.string().min(1).optional(),
            defaultValue: z.string().optional(),
            userViewable: z.boolean().optional(),
            userEditable: z.boolean().optional(),
            rules: z.string().optional(),
            fieldType: z.string().optional(),
        });
        const data = variableSchema.parse(req.body);

        const variable = await prisma.eggVariable.findFirst({
            where: { id: variableId, eggId: id },
        });

        if (!variable) {
            throw new AppError(404, 'Variable not found');
        }

        const updated = await prisma.eggVariable.update({
            where: { id: variableId },
            data,
        });

        res.json({ variable: updated });
    } catch (error) {
        if (error instanceof z.ZodError) {
            return next(new AppError(400, error.errors[0].message));
        }
        next(error);
    }
});

// DELETE /api/eggs/:id/variables/:variableId - Delete egg variable
router.delete('/:id/variables/:variableId', requireAdmin, async (req: AuthRequest, res, next) => {
    try {
        const { id, variableId } = req.params;

        const variable = await prisma.eggVariable.findFirst({
            where: { id: variableId, eggId: id },
        });

        if (!variable) {
            throw new AppError(404, 'Variable not found');
        }

        await prisma.eggVariable.delete({
            where: { id: variableId },
        });

        res.json({ message: 'Variable deleted' });
    } catch (error) {
        next(error);
    }
});

export { router as eggsRouter };
